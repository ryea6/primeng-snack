 // 🚀 MAIN METHOD - Works with any Observable from any service
  withLoadingUpdates<T>(
    loadingMessage: string,
    observable: Observable<T>,
    options: {
      successMessage: string
      errorMessage?: string
      onSuccess?: (result: T) => void
      onError?: (error: any) => void
      successDelay?: number
      retryCallback?: () => void // ✅ OPTIONAL!
    },
  ): Observable<T> {
    const {
      successMessage,
      errorMessage = "Operation failed. Please try again.",
      onSuccess,
      onError,
      successDelay = 800,
      retryCallback, // ✅ Optional - no retry button if not provided
    } = options

    const loadingId = this.loading(loadingMessage, "Please Wait")

    return observable.pipe(
      tap((result) => {
        this.update(loadingId, {
          type: "success",
          title: "Complete",
          message: successMessage,
          duration: 3000,
          showCloseButton: true,
        })

        if (onSuccess) {
          setTimeout(() => onSuccess(result), successDelay)
        }
      }),
      catchError((error) => {
        // ✅ Only show retry button if retryCallback is provided
        if (retryCallback) {
          this.update(loadingId, {
            type: "error",
            title: "Error",
            message: errorMessage,
            duration: 0,
            showCloseButton: true,
            actionLabel: "Retry",
            actionCallback: retryCallback,
          })
        } else {
          // ✅ No retry button - just error message
          this.update(loadingId, {
            type: "error",
            title: "Error",
            message: errorMessage,
            duration: 0,
            showCloseButton: true,
          })
        }

        onError?.(error)
        return throwError(() => error)
      }),
    )
  }








///////////////////////////////--------------------------------------------------------------//////////////////////////////////////
import { Component } from "@angular/core"
import { CommonModule } from "@angular/common"
import { MatButtonModule } from "@angular/material/button"
import { MatCardModule } from "@angular/material/card"
import type { Router } from "@angular/router"
import type { ClaimsDataService } from "../services/claims-data.service"
import type { ModernSnackbarService } from "../services/modern-snackbar.service"

@Component({
  selector: "app-claims-with-snackbars",
  standalone: true,
  imports: [CommonModule, MatButtonModule, MatCardModule],
  template: `
    <div class="container">
      <h1>🚀 Service Methods with Snackbars</h1>
      
      <div class="examples-grid">
        <!-- GET Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>GET Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Loading data with feedback</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-button (click)="loadClaim()">Load Claim</button>
            <button mat-button (click)="loadAllClaims()">Load All Claims</button>
            <button mat-button (click)="searchClaims()">Search Claims</button>
          </mat-card-actions>
        </mat-card>

        <!-- CREATE Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>CREATE Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Create with success feedback and navigation</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="primary" (click)="createClaim()">
              Create Claim
            </button>
            <button mat-raised-button color="primary" (click)="createAndNavigate()">
              Create & Navigate
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- UPDATE Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>UPDATE Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Update with retry and feedback</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="accent" (click)="updateClaim()">
              Update Claim
            </button>
            <button mat-raised-button color="accent" (click)="updateWithRetry()">
              Update with Retry
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- BULK Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>BULK Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Long-running operations with progress</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="bulkUpdate()">Bulk Update</button>
            <button mat-raised-button (click)="exportClaims()">Export Claims</button>
          </mat-card-actions>
        </mat-card>

        <!-- DELETE Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>DELETE Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Delete with confirmation and feedback</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="warn" (click)="deleteClaim()">
              Delete Claim
            </button>
            <button mat-raised-button color="warn" (click)="deleteWithConfirm()">
              Delete with Confirm
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- ERROR Handling -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>ERROR Handling</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Different error scenarios</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="warn" (click)="triggerError()">
              Trigger Error
            </button>
            <button mat-raised-button color="warn" (click)="triggerNetworkError()">
              Network Error
            </button>
          </mat-card-actions>
        </mat-card>
      </div>
    </div>
  `,
  styles: [
    `
    .container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 24px;
      margin: 32px 0;
    }

    .example-card {
      height: 200px;
      display: flex;
      flex-direction: column;
    }

    mat-card-content {
      flex: 1;
    }

    mat-card-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 16px;
    }
  `,
  ],
})
export class ClaimsWithSnackbarsComponent {
  constructor(
    private claimsDataService: ClaimsDataService,
    private snackbar: ModernSnackbarService,
    private router: Router,
  ) {}

  // ✅ GET Operations - Usually silent or with minimal feedback
  loadClaim(): void {
    this.snackbar
      .withLoadingUpdates("Loading claim details...", this.claimsDataService.getClaimSrvc("123"), {
        successMessage: "Claim loaded successfully!",
        onSuccess: (claim) => {
          console.log("Loaded claim:", claim)
          // Update UI with claim data
        },
      })
      .subscribe()
  }

  loadAllClaims(): void {
    this.snackbar
      .withLoadingUpdates("Loading all claims...", this.claimsDataService.getAllClaimsSrvc(), {
        successMessage: "All claims loaded!",
        onSuccess: (claims) => {
          console.log(`Loaded ${claims.length} claims`)
          // Update UI with claims data
        },
      })
      .subscribe()
  }

  searchClaims(): void {
    this.snackbar
      .withLoadingUpdates("Searching claims...", this.claimsDataService.searchClaimsSrvc("john"), {
        successMessage: "Search completed!",
        onSuccess: (results) => {
          console.log(`Found ${results.length} matching claims`)
        },
        retryCallback: () => this.searchClaims(),
      })
      .subscribe()
  }

  // ✅ CREATE Operations - Show success and navigate
  createClaim(): void {
    const newClaim = {
      claimNumber: "CLM-2024-NEW",
      claimant: "New Claimant",
      amount: 5000,
      status: "pending",
    }

    this.snackbar
      .withLoadingUpdates("Creating new claim...", this.claimsDataService.createClaimSrvc(newClaim), {
        successMessage: "Claim created successfully!",
        onSuccess: (claim) => {
          console.log("Created claim:", claim)
          // Update local state or refresh list
        },
        retryCallback: () => this.createClaim(),
      })
      .subscribe()
  }

  createAndNavigate(): void {
    const newClaim = {
      claimNumber: "CLM-2024-NAV",
      claimant: "Navigate User",
      amount: 7500,
      status: "pending",
    }

    this.snackbar
      .withLoadingUpdates("Creating claim...", this.claimsDataService.createClaimSrvc(newClaim), {
        successMessage: "Claim created! Redirecting...",
        onSuccess: (claim) => this.router.navigate(["/claims", claim.id]),
        successDelay: 1000, // Wait a bit before navigating
        retryCallback: () => this.createAndNavigate(),
      })
      .subscribe()
  }

  // ✅ UPDATE Operations - Show success feedback
  updateClaim(): void {
    const updates = { amount: 9999, status: "under_review" }

    this.snackbar
      .withLoadingUpdates("Updating claim...", this.claimsDataService.updateClaimSrvc("123", updates), {
        successMessage: "Claim updated successfully!",
        onSuccess: (updatedClaim) => {
          console.log("Updated claim:", updatedClaim)
          // Update local state
        },
      })
      .subscribe()
  }

  updateWithRetry(): void {
    const updates = { status: "approved" }

    this.snackbar
      .withLoadingUpdates("Approving claim...", this.claimsDataService.updateClaimSrvc("123", updates), {
        successMessage: "Claim approved successfully!",
        errorMessage: "Failed to approve claim. Please try again.",
        onSuccess: (claim) => console.log("Approved:", claim),
        retryCallback: () => this.updateWithRetry(), // ✅ Retry on error
      })
      .subscribe()
  }

  // ✅ BULK Operations - Long running with progress
  bulkUpdate(): void {
    const updates = [
      { id: "1", data: { status: "approved" } },
      { id: "2", data: { status: "approved" } },
      { id: "3", data: { status: "rejected" } },
    ]

    this.snackbar
      .withLoadingUpdates("Processing bulk update...", this.claimsDataService.bulkUpdateSrvc(updates), {
        successMessage: "Bulk update completed successfully!",
        onSuccess: (results) => {
          console.log(`Updated ${results.length} claims`)
        },
        retryCallback: () => this.bulkUpdate(),
      })
      .subscribe()
  }

  exportClaims(): void {
    this.snackbar
      .withLoadingUpdates("Preparing export...", this.claimsDataService.exportClaimsSrvc("excel"), {
        successMessage: "Export ready for download!",
        onSuccess: (blob) => {
          // Trigger download
          const url = window.URL.createObjectURL(blob)
          const a = document.createElement("a")
          a.href = url
          a.download = "claims-export.xlsx"
          a.click()
          window.URL.revokeObjectURL(url)
        },
      })
      .subscribe()
  }

  // ✅ DELETE Operations - Show confirmation
  deleteClaim(): void {
    this.snackbar
      .withLoadingUpdates("Deleting claim...", this.claimsDataService.deleteClaimSrvc("123"), {
        successMessage: "Claim deleted successfully!",
        onSuccess: () => {
          console.log("Claim deleted")
          // Remove from local state or refresh list
        },
        retryCallback: () => this.deleteClaim(),
      })
      .subscribe()
  }

  deleteWithConfirm(): void {
    // Show confirmation first
    const confirmId = this.snackbar.show({
      type: "warning",
      title: "Confirm Delete",
      message: "Are you sure you want to delete this claim?",
      duration: 0,
      actionLabel: "Delete",
      actionCallback: () => {
        this.snackbar.dismiss(confirmId)
        this.deleteClaim()
      },
    })
  }

  // ✅ ERROR Handling Examples
  triggerError(): void {
    // Simulate a service call that will fail
    this.snackbar
      .withLoadingUpdates("Processing request...", this.claimsDataService.getClaimSrvc("nonexistent"), {
        successMessage: "This won't show",
        errorMessage: "Claim not found. Please check the ID.",
        retryCallback: () => this.triggerError(),
      })
      .subscribe()
  }

  triggerNetworkError(): void {
    // Simulate network error
    this.snackbar
      .withLoadingUpdates("Connecting to server...", this.claimsDataService.getClaimSrvc("network-fail"), {
        successMessage: "Connected successfully",
        errorMessage: "Network error. Please check your connection.",
        retryCallback: () => this.triggerNetworkError(),
      })
      .subscribe()
  }
}


///////////////////////////////////---------------------------------------------------------------/////////////////////////////////////////////////
import { Component } from "@angular/core"
import { CommonModule } from "@angular/common"
import { MatButtonModule } from "@angular/material/button"
import { MatCardModule } from "@angular/material/card"
import {
  switchMap,
  forkJoin,
  map,
  filter,
  debounceTime,
  distinctUntilChanged,
  catchError,
  finalize,
  tap,
  delay,
  retry,
  retryWhen,
  timer,
} from "rxjs"
import type { ClaimsDataService } from "../services/claims-data.service"
import type { ModernSnackbarService } from "../services/modern-snackbar.service"

@Component({
  selector: "app-rxjs-patterns",
  standalone: true,
  imports: [CommonModule, MatButtonModule, MatCardModule],
  template: `
    <div class="container">
      <h1>🔄 RxJS Operators with Snackbars</h1>
      
      <div class="examples-grid">
        <!-- SwitchMap Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>🔄 SwitchMap</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Chain operations, cancel previous</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="primary" (click)="createThenLoad()">
              Create → Load
            </button>
            <button mat-raised-button color="primary" (click)="updateThenRefresh()">
              Update → Refresh
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- ForkJoin Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>🍴 ForkJoin</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Multiple parallel operations</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="accent" (click)="loadMultipleData()">
              Load All Data
            </button>
            <button mat-raised-button color="accent" (click)="bulkOperations()">
              Bulk Operations
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Map & Filter -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>🗺️ Map & Filter</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Transform and filter data</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="loadAndTransform()">
              Load & Transform
            </button>
            <button mat-raised-button (click)="loadAndFilter()">
              Load & Filter
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Retry Patterns -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>🔁 Retry Patterns</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Advanced retry strategies</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="warn" (click)="retryWithDelay()">
              Retry with Delay
            </button>
            <button mat-raised-button color="warn" (click)="exponentialBackoff()">
              Exponential Backoff
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Debounce & Search -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>⏱️ Debounce</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Debounced search operations</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="debouncedSearch()">
              Debounced Search
            </button>
            <button mat-raised-button (click)="typeaheadSearch()">
              Typeahead Search
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Complex Workflows -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>🏗️ Complex Workflows</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Multi-step operations</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="primary" (click)="complexWorkflow()">
              Multi-Step Process
            </button>
            <button mat-raised-button color="primary" (click)="conditionalFlow()">
              Conditional Flow
            </button>
          </mat-card-actions>
        </mat-card>
      </div>

      <!-- Code Examples -->
      <div class="code-examples">
        <h3>💻 Code Examples</h3>
        <pre><code>// 🔄 SwitchMap - Chain operations
this.snackbar.withLoadingUpdates('Creating...', 
  this.service.createClaim(data), {{ successMessage: 'Created!' }}
).pipe(
  switchMap(claim => this.snackbar.withLoadingUpdates('Loading details...', 
    this.service.getClaim(claim.id), {{ successMessage: 'Loaded!' }}
  ))
).subscribe();

// 🍴 ForkJoin - Parallel operations  
forkJoin({{
  claims: this.snackbar.withLoadingUpdates('Loading claims...', 
    this.service.getClaims(), {{ successMessage: 'Claims loaded!' }}),
  users: this.snackbar.withLoadingUpdates('Loading users...', 
    this.userService.getUsers(), {{ successMessage: 'Users loaded!' }})
}}).subscribe();

// 🗺️ Map & Filter - Transform data
this.snackbar.withLoadingUpdates('Loading...', 
  this.service.getClaims(), {{ successMessage: 'Loaded!' }}
).pipe(
  map(claims => claims.filter(c => c.status === 'active')),
  map(claims => claims.map(c => ({{ ...c, displayName: c.claimant.toUpperCase() }})))
).subscribe();</code></pre>
      </div>
    </div>
  `,
  styles: [
    `
    .container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 24px;
      margin: 32px 0;
    }

    .example-card {
      height: 180px;
      display: flex;
      flex-direction: column;
    }

    mat-card-content {
      flex: 1;
    }

    mat-card-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .code-examples {
      margin-top: 32px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    pre {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 16px;
    }
  `,
  ],
})
export class RxjsPatternsComponent {
  constructor(
    private claimsService: ClaimsDataService,
    private snackbar: ModernSnackbarService,
  ) {}

  // 🔄 SWITCHMAP - Chain operations, cancel previous
  createThenLoad(): void {
    const newClaim = {
      claimNumber: "CLM-CHAIN-001",
      claimant: "Chain User",
      amount: 5000,
      status: "pending",
    }

    this.snackbar
      .withLoadingUpdates("Creating claim...", this.claimsService.createClaimSrvc(newClaim), {
        successMessage: "Claim created!",
      })
      .pipe(
        // ✅ Chain another operation
        switchMap((createdClaim) =>
          this.snackbar.withLoadingUpdates(
            "Loading claim details...",
            this.claimsService.getClaimSrvc(createdClaim.id),
            {
              successMessage: "Details loaded!",
            },
          ),
        ),
      )
      .subscribe((finalClaim) => {
        console.log("Final claim with details:", finalClaim)
      })
  }

  updateThenRefresh(): void {
    this.snackbar
      .withLoadingUpdates("Updating claim...", this.claimsService.updateClaimSrvc("123", { status: "approved" }), {
        successMessage: "Claim updated!",
      })
      .pipe(
        // ✅ Refresh the list after update
        switchMap(() =>
          this.snackbar.withLoadingUpdates("Refreshing list...", this.claimsService.getAllClaimsSrvc(), {
            successMessage: "List refreshed!",
          }),
        ),
      )
      .subscribe((allClaims) => {
        console.log("Updated claims list:", allClaims)
      })
  }

  // 🍴 FORKJOIN - Multiple parallel operations
  loadMultipleData(): void {
    const loadingId = this.snackbar.loading("Loading all data...", "Please Wait")

    forkJoin({
      claims: this.claimsService.getAllClaimsSrvc(),
      recentClaims: this.claimsService.searchClaimsSrvc("recent"),
      exportData: this.claimsService.exportClaimsSrvc("json"),
    })
      .pipe(
        tap(() => {
          this.snackbar.update(loadingId, {
            type: "success",
            title: "Complete",
            message: "All data loaded successfully!",
            duration: 3000,
          })
        }),
        catchError((error) => {
          this.snackbar.update(loadingId, {
            type: "error",
            title: "Error",
            message: "Failed to load some data",
            duration: 0,
            actionLabel: "Retry",
            actionCallback: () => this.loadMultipleData(),
          })
          throw error
        }),
      )
      .subscribe((results) => {
        console.log("All data loaded:", results)
      })
  }

  bulkOperations(): void {
    const updates = [
      { id: "1", data: { status: "approved" } },
      { id: "2", data: { status: "approved" } },
      { id: "3", data: { status: "rejected" } },
    ]

    // ✅ ForkJoin with individual snackbar updates
    const operations = updates.map((update) =>
      this.snackbar.withLoadingUpdates(
        `Updating claim ${update.id}...`,
        this.claimsService.updateClaimSrvc(update.id, update.data),
        {
          successMessage: `Claim ${update.id} updated!`,
        },
      ),
    )

    forkJoin(operations).subscribe((results) => {
      this.snackbar.success(`${results.length} claims updated successfully!`, "Bulk Update Complete")
    })
  }

  // 🗺️ MAP & FILTER - Transform and filter data
  loadAndTransform(): void {
    this.snackbar
      .withLoadingUpdates("Loading claims...", this.claimsService.getAllClaimsSrvc(), {
        successMessage: "Claims loaded and transformed!",
      })
      .pipe(
        // ✅ Transform the data
        map((claims) =>
          claims.map((claim) => ({
            ...claim,
            displayName: `${claim.claimNumber} - ${claim.claimant}`,
            formattedAmount: `$${claim.amount.toLocaleString()}`,
            isHighValue: claim.amount > 10000,
          })),
        ),
        // ✅ Filter high-value claims
        map((claims) => claims.filter((claim) => claim.isHighValue)),
      )
      .subscribe((highValueClaims) => {
        console.log("High-value claims:", highValueClaims)
        this.snackbar.success(`Found ${highValueClaims.length} high-value claims`, "Analysis Complete")
      })
  }

  loadAndFilter(): void {
    this.snackbar
      .withLoadingUpdates("Loading and filtering claims...", this.claimsService.getAllClaimsSrvc(), {
        successMessage: "Claims filtered!",
      })
      .pipe(
        // ✅ Filter active claims only
        map((claims) => claims.filter((claim) => claim.status === "active")),
        // ✅ Only proceed if we have results
        filter((claims) => claims.length > 0),
      )
      .subscribe((activeClaims) => {
        console.log("Active claims:", activeClaims)
      })
  }

  // 🔁 RETRY PATTERNS - Advanced retry strategies
  retryWithDelay(): void {
    this.snackbar
      .withLoadingUpdates("Attempting operation...", this.claimsService.getClaimSrvc("might-fail"), {
        successMessage: "Operation succeeded!",
      })
      .pipe(
        // ✅ Retry 3 times with 2 second delay
        retryWhen((errors) =>
          errors.pipe(
            tap(() => this.snackbar.warning("Retrying in 2 seconds...", "Retry")),
            delay(2000),
            retry(3),
          ),
        ),
        catchError((error) => {
          this.snackbar.error("Operation failed after 3 retries", "Failed")
          throw error
        }),
      )
      .subscribe()
  }

  exponentialBackoff(): void {
    let retryCount = 0

    this.snackbar
      .withLoadingUpdates("Attempting with backoff...", this.claimsService.getClaimSrvc("unstable"), {
        successMessage: "Operation succeeded!",
      })
      .pipe(
        retryWhen((errors) =>
          errors.pipe(
            tap(() => {
              retryCount++
              const delay = Math.pow(2, retryCount) * 1000 // 2s, 4s, 8s...
              this.snackbar.warning(`Retrying in ${delay / 1000} seconds... (${retryCount}/3)`, "Backoff")
            }),
            switchMap(() => timer(Math.pow(2, retryCount) * 1000)),
            retry(3),
          ),
        ),
      )
      .subscribe()
  }

  // ⏱️ DEBOUNCE - Debounced operations
  debouncedSearch(): void {
    // Simulate search input changes
    const searchTerms = ["john", "jane", "bob"]
    let currentIndex = 0

    const searchInterval = setInterval(() => {
      if (currentIndex >= searchTerms.length) {
        clearInterval(searchInterval)
        return
      }

      const term = searchTerms[currentIndex++]

      // ✅ Debounced search with snackbar
      timer(0)
        .pipe(
          debounceTime(300),
          distinctUntilChanged(),
          switchMap(() =>
            this.snackbar.withLoadingUpdates(`Searching for "${term}"...`, this.claimsService.searchClaimsSrvc(term), {
              successMessage: `Found results for "${term}"!`,
            }),
          ),
        )
        .subscribe((results) => {
          console.log(`Search results for "${term}":`, results)
        })
    }, 500)
  }

  typeaheadSearch(): void {
    // Simulate typeahead search
    this.snackbar
      .withLoadingUpdates(
        "Searching...",
        timer(300).pipe(switchMap(() => this.claimsService.searchClaimsSrvc("typeahead"))),
        {
          successMessage: "Search completed!",
        },
      )
      .pipe(
        debounceTime(300),
        distinctUntilChanged(),
        switchMap((results) =>
          // ✅ Chain another operation based on results
          results.length > 0 ? this.claimsService.getClaimSrvc(results[0].id) : timer(0).pipe(map(() => null)),
        ),
      )
      .subscribe((detailedResult) => {
        if (detailedResult) {
          this.snackbar.success("Detailed result loaded!", "Typeahead")
        }
      })
  }

  // 🏗️ COMPLEX WORKFLOWS - Multi-step operations
  complexWorkflow(): void {
    const newClaim = {
      claimNumber: "CLM-COMPLEX-001",
      claimant: "Complex User",
      amount: 15000,
      status: "pending",
    }

    // ✅ Multi-step workflow with different snackbars
    this.snackbar
      .withLoadingUpdates("Step 1: Creating claim...", this.claimsService.createClaimSrvc(newClaim), {
        successMessage: "Step 1 complete!",
      })
      .pipe(
        // Step 2: Update the claim
        switchMap((claim) =>
          this.snackbar.withLoadingUpdates(
            "Step 2: Processing claim...",
            this.claimsService.updateClaimSrvc(claim.id, { status: "processing" }),
            {
              successMessage: "Step 2 complete!",
            },
          ),
        ),
        // Step 3: Generate report
        switchMap((claim) =>
          this.snackbar.withLoadingUpdates("Step 3: Generating report...", this.claimsService.exportClaimsSrvc("pdf"), {
            successMessage: "Workflow complete!",
          }),
        ),
        // ✅ Final success message
        finalize(() => {
          this.snackbar.success("Complex workflow completed successfully!", "Success")
        }),
      )
      .subscribe((finalResult) => {
        console.log("Workflow completed:", finalResult)
      })
  }

  conditionalFlow(): void {
    this.snackbar
      .withLoadingUpdates("Loading claim...", this.claimsService.getClaimSrvc("123"), {
        successMessage: "Claim loaded!",
      })
      .pipe(
        // ✅ Conditional logic based on claim data
        switchMap((claim) => {
          if (claim.amount > 10000) {
            // High-value claim - needs approval
            return this.snackbar.withLoadingUpdates(
              "Requesting approval...",
              this.claimsService.updateClaimSrvc(claim.id, { status: "pending_approval" }),
              {
                successMessage: "Approval requested!",
              },
            )
          } else {
            // Low-value claim - auto-approve
            return this.snackbar.withLoadingUpdates(
              "Auto-approving...",
              this.claimsService.updateClaimSrvc(claim.id, { status: "approved" }),
              {
                successMessage: "Auto-approved!",
              },
            )
          }
        }),
      )
      .subscribe((result) => {
        console.log("Conditional flow result:", result)
      })
  }
}




//////////////////////////////////////-----------------------------------------//////////////////////////////////////////////////////

import { Injectable } from "@angular/core"
import type { HttpClient } from "@angular/common/http"
import {
  type Observable,
  forkJoin,
  switchMap,
  map,
  tap,
  catchError,
  retry,
  retryWhen,
  timer,
  debounceTime,
  distinctUntilChanged,
} from "rxjs"
import type { ModernSnackbarService } from "./modern-snackbar.service"

export interface BatchOperation<T> {
  operation: Observable<T>
  loadingMessage: string
  successMessage: string
  errorMessage?: string
}

@Injectable({
  providedIn: "root",
})
export class AdvancedPatternsService {
  constructor(
    private http: HttpClient,
    private snackbar: ModernSnackbarService,
  ) {}

  // 🍴 FORKJOIN - Parallel operations with individual progress
  runParallelOperations<T>(operations: BatchOperation<T>[]): Observable<T[]> {
    const observables = operations.map((op) =>
      this.snackbar.withLoadingUpdates(op.loadingMessage, op.operation, {
        successMessage: op.successMessage,
        errorMessage: op.errorMessage,
      }),
    )

    return forkJoin(observables).pipe(
      tap((results) => {
        this.snackbar.success(`All ${results.length} operations completed!`, "Batch Complete")
      }),
      catchError((error) => {
        this.snackbar.error("Some operations failed", "Batch Error")
        throw error
      }),
    )
  }

  // 🔄 SWITCHMAP - Sequential operations with cancellation
  runSequentialOperations<T>(operations: BatchOperation<T>[]): Observable<T> {
    return operations.reduce(
      (acc, op, index) =>
        acc.pipe(
          switchMap(() =>
            this.snackbar.withLoadingUpdates(`${op.loadingMessage} (${index + 1}/${operations.length})`, op.operation, {
              successMessage: op.successMessage,
            }),
          ),
        ),
      timer(0).pipe(switchMap(() => operations[0].operation)),
    )
  }

  // 🔁 RETRY - Smart retry with exponential backoff
  withSmartRetry<T>(
    operation: Observable<T>,
    options: {
      maxRetries?: number
      baseDelay?: number
      loadingMessage: string
      successMessage: string
    },
  ): Observable<T> {
    const { maxRetries = 3, baseDelay = 1000, loadingMessage, successMessage } = options
    let retryCount = 0

    return this.snackbar
      .withLoadingUpdates(loadingMessage, operation, {
        successMessage,
      })
      .pipe(
        retryWhen((errors) =>
          errors.pipe(
            tap(() => {
              retryCount++
              const delay = baseDelay * Math.pow(2, retryCount - 1)
              this.snackbar.warning(`Retry ${retryCount}/${maxRetries} in ${delay / 1000}s...`, "Retrying")
            }),
            switchMap(() => timer(baseDelay * Math.pow(2, retryCount - 1))),
            retry(maxRetries),
          ),
        ),
        catchError((error) => {
          this.snackbar.error(`Failed after ${maxRetries} attempts`, "Failed")
          throw error
        }),
      )
  }

  // ⏱️ DEBOUNCE - Debounced operations with loading states
  withDebounce<T>(
    operation: Observable<T>,
    debounceMs = 300,
    options: {
      loadingMessage: string
      successMessage: string
    },
  ): Observable<T> {
    return timer(0).pipe(
      debounceTime(debounceMs),
      distinctUntilChanged(),
      switchMap(() =>
        this.snackbar.withLoadingUpdates(options.loadingMessage, operation, {
          successMessage: options.successMessage,
        }),
      ),
    )
  }

  // 🏗️ WORKFLOW - Complex multi-step workflows
  runWorkflow<T>(
    steps: Array<{
      name: string
      operation: (previousResult?: any) => Observable<T>
      loadingMessage: string
      successMessage: string
      condition?: (previousResult: any) => boolean
    }>,
  ): Observable<T> {
    return steps.reduce(
      (acc, step, index) =>
        acc.pipe(
          switchMap((previousResult) => {
            // Check condition if provided
            if (step.condition && !step.condition(previousResult)) {
              return timer(0).pipe(map(() => previousResult))
            }

            return this.snackbar.withLoadingUpdates(
              `${step.name} (${index + 1}/${steps.length})...`,
              step.operation(previousResult),
              {
                successMessage: step.successMessage,
              },
            )
          }),
        ),
      timer(0).pipe(switchMap(() => steps[0].operation())),
    )
  }

  // 📊 PROGRESS - Operations with progress tracking
  withProgress<T>(
    operations: Observable<T>[],
    options: {
      totalMessage: string
      successMessage: string
    },
  ): Observable<T[]> {
    const total = operations.length
    let completed = 0

    const loadingId = this.snackbar.loading(`${options.totalMessage} (0/${total})`, "Progress")

    const trackedOperations = operations.map((op) =>
      op.pipe(
        tap(() => {
          completed++
          this.snackbar.update(loadingId, {
            message: `${options.totalMessage} (${completed}/${total})`,
          })
        }),
      ),
    )

    return forkJoin(trackedOperations).pipe(
      tap(() => {
        this.snackbar.update(loadingId, {
          type: "success",
          title: "Complete",
          message: options.successMessage,
          duration: 3000,
        })
      }),
      catchError((error) => {
        this.snackbar.update(loadingId, {
          type: "error",
          title: "Error",
          message: `Failed at ${completed}/${total}`,
          duration: 0,
        })
        throw error
      }),
    )
  }
}

