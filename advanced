import { Injectable } from "@angular/core"
import type { HttpClient } from "@angular/common/http"
import { type Observable, forkJoin, switchMap, tap, catchError, timer } from "rxjs"
import type { ModernSnackbarService } from "./modern-snackbar.service"

export interface BatchOperation<T> {
  operation: Observable<T>
  loadingMessage: string
  successMessage: string
  errorMessage?: string
}

@Injectable({
  providedIn: "root",
})
export class AdvancedPatternsService {
  constructor(
    private http: HttpClient,
    private snackbar: ModernSnackbarService,
  ) {}

  // üç¥ FORKJOIN - Parallel operations with individual progress
  runParallelOperations<T>(operations: BatchOperation<T>[]): Observable<T[]> {
    // ‚úÖ Each operation gets its own snackbar immediately
    const observables = operations.map((op) =>
      this.snackbar.withLoadingUpdates(op.loadingMessage, op.operation, {
        successMessage: op.successMessage,
        errorMessage: op.errorMessage,
      }),
    )

    // ‚úÖ ForkJoin waits for ALL to complete, then shows final message
    return forkJoin(observables).pipe(
      tap((results) => {
        this.snackbar.success(`All ${results.length} operations completed!`, "Batch Complete")
      }),
      catchError((error) => {
        this.snackbar.error("Some operations failed", "Batch Error")
        throw error
      }),
    )
  }

  // üîÑ SEQUENTIAL - One after another (different from parallel)
  runSequentialOperations<T>(operations: BatchOperation<T>[]): Observable<T> {
    return operations.reduce(
      (acc, op, index) =>
        acc.pipe(
          switchMap(() =>
            this.snackbar.withLoadingUpdates(`${op.loadingMessage} (${index + 1}/${operations.length})`, op.operation, {
              successMessage: op.successMessage,
            }),
          ),
        ),
      timer(0).pipe(switchMap(() => operations[0].operation)),
    )
  }

  // üéØ SMART BATCH - With progress tracking
  runBatchWithProgress<T>(
    operations: BatchOperation<T>[],
    options?: {
      batchName?: string
      showIndividualProgress?: boolean
    },
  ): Observable<T[]> {
    const { batchName = "Batch", showIndividualProgress = true } = options || {}
    const total = operations.length
    let completed = 0

    // Show overall progress
    const progressId = this.snackbar.loading(`${batchName} starting... (0/${total})`, "Progress")

    const observables = operations.map((op, index) => {
      if (showIndividualProgress) {
        // Show individual snackbars
        return this.snackbar.withLoadingUpdates(op.loadingMessage, op.operation, {
          successMessage: op.successMessage,
          errorMessage: op.errorMessage,
        })
      } else {
        // Just track progress, no individual snackbars
        return op.operation.pipe(
          tap(() => {
            completed++
            this.snackbar.update(progressId, {
              message: `${batchName} progress... (${completed}/${total})`,
            })
          }),
        )
      }
    })

    return forkJoin(observables).pipe(
      tap((results) => {
        this.snackbar.update(progressId, {
          type: "success",
          title: "Complete",
          message: `${batchName} completed! ${results.length} operations successful.`,
          duration: 3000,
        })
      }),
      catchError((error) => {
        this.snackbar.update(progressId, {
          type: "error",
          title: "Error",
          message: `${batchName} failed. Some operations may have succeeded.`,
          duration: 0,
        })
        throw error
      }),
    )
  }
}




import { Component } from "@angular/core"
import { CommonModule } from "@angular/common"
import { MatButtonModule } from "@angular/material/button"
import { MatCardModule } from "@angular/material/card"
import type { ClaimsDataService } from "../services/claims-data.service"
import type { AdvancedPatternsService, BatchOperation } from "../services/advanced-patterns.service"

@Component({
  selector: "app-parallel-operations-demo",
  standalone: true,
  imports: [CommonModule, MatButtonModule, MatCardModule],
  template: `
    <div class="container">
      <h1>üç¥ Parallel Operations with ForkJoin</h1>
      
      <div class="examples-grid">
        <!-- Basic Parallel Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>üîÑ Basic Parallel</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Multiple independent operations running simultaneously</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="primary" (click)="basicParallelExample()">
              Run 3 Parallel Operations
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Bulk Updates -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>üìù Bulk Updates</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Update multiple claims simultaneously</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="accent" (click)="bulkUpdateExample()">
              Update 5 Claims
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Mixed Operations -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>üéØ Mixed Operations</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Different types of operations in parallel</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="warn" (click)="mixedOperationsExample()">
              Mixed Operations
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- File Processing -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>üìÅ File Processing</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Process multiple files simultaneously</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="fileProcessingExample()">
              Process 4 Files
            </button>
          </mat-card-actions>
        </mat-card>
      </div>

      <!-- What You'll See -->
      <div class="behavior-explanation">
        <h2>üé¨ What Happens When You Click:</h2>
        <div class="behavior-steps">
          <div class="step">
            <h3>1. üì± Individual Loading Snackbars</h3>
            <p>Each operation shows its own loading snackbar immediately</p>
          </div>
          <div class="step">
            <h3>2. ‚ö° Parallel Execution</h3>
            <p>All HTTP requests run simultaneously (not sequential)</p>
          </div>
          <div class="step">
            <h3>3. ‚úÖ Individual Success Messages</h3>
            <p>As each operation completes, its loading becomes success</p>
          </div>
          <div class="step">
            <h3>4. üéâ Final Summary</h3>
            <p>When ALL complete, you get a "Batch Complete" message</p>
          </div>
        </div>
      </div>

      <!-- Code Examples -->
      <div class="code-examples">
        <h3>üíª Usage Code</h3>
        <pre><code>// ‚úÖ BASIC USAGE
const operations: BatchOperation&lt;any&gt;[] = [
  {{
    operation: this.claimsService.updateClaimSrvc('1', {{ status: 'approved' }}),
    loadingMessage: 'Approving claim 1...',
    successMessage: 'Claim 1 approved!',
    errorMessage: 'Failed to approve claim 1'
  }},
  {{
    operation: this.claimsService.updateClaimSrvc('2', {{ status: 'approved' }}),
    loadingMessage: 'Approving claim 2...',
    successMessage: 'Claim 2 approved!',
    errorMessage: 'Failed to approve claim 2'
  }}
];

// üöÄ Run them all in parallel
this.advancedPatterns.runParallelOperations(operations).subscribe({{
  next: (results) => {{
    console.log('All operations completed:', results);
    // Handle the combined results
  }},
  error: (error) => {{
    console.log('Some operations failed:', error);
    // Handle partial failures
  }}
}});</code></pre>
      </div>
    </div>
  `,
  styles: [
    `
    .container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 24px;
      margin: 32px 0;
    }

    .example-card {
      height: 200px;
      display: flex;
      flex-direction: column;
    }

    mat-card-content {
      flex: 1;
    }

    .behavior-explanation {
      margin: 40px 0;
      padding: 24px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    .behavior-steps {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .step {
      background: white;
      padding: 16px;
      border-radius: 8px;
      border-left: 4px solid #007bff;
    }

    .step h3 {
      margin-top: 0;
      color: #495057;
    }

    .step p {
      margin: 8px 0 0 0;
      color: #6c757d;
    }

    .code-examples {
      margin-top: 32px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    pre {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 16px;
    }
  `,
  ],
})
export class ParallelOperationsDemoComponent {
  constructor(
    private claimsService: ClaimsDataService,
    private advancedPatterns: AdvancedPatternsService,
  ) {}

  // ‚úÖ BASIC PARALLEL EXAMPLE
  basicParallelExample(): void {
    const operations: BatchOperation<any>[] = [
      {
        operation: this.claimsService.getClaimSrvc("1"),
        loadingMessage: "Loading claim 1...",
        successMessage: "Claim 1 loaded!",
        errorMessage: "Failed to load claim 1",
      },
      {
        operation: this.claimsService.getClaimSrvc("2"),
        loadingMessage: "Loading claim 2...",
        successMessage: "Claim 2 loaded!",
        errorMessage: "Failed to load claim 2",
      },
      {
        operation: this.claimsService.getClaimSrvc("3"),
        loadingMessage: "Loading claim 3...",
        successMessage: "Claim 3 loaded!",
        errorMessage: "Failed to load claim 3",
      },
    ]

    // üöÄ This will show 3 loading snackbars immediately
    this.advancedPatterns.runParallelOperations(operations).subscribe({
      next: (results) => {
        console.log("‚úÖ All 3 claims loaded:", results)
        // You now have all 3 claims data
        // Plus you got individual success messages
        // Plus you got a final "Batch Complete" message
      },
      error: (error) => {
        console.log("‚ùå Some claims failed to load:", error)
        // Even if one fails, you'll see which ones succeeded
      },
    })
  }

  // ‚úÖ BULK UPDATE EXAMPLE
  bulkUpdateExample(): void {
    const claimIds = ["101", "102", "103", "104", "105"]

    const operations: BatchOperation<any>[] = claimIds.map((id) => ({
      operation: this.claimsService.updateClaimSrvc(id, { status: "approved" }),
      loadingMessage: `Approving claim ${id}...`,
      successMessage: `Claim ${id} approved!`,
      errorMessage: `Failed to approve claim ${id}`,
    }))

    // üöÄ This will show 5 loading snackbars immediately
    this.advancedPatterns.runParallelOperations(operations).subscribe({
      next: (results) => {
        console.log(`‚úÖ All ${results.length} claims approved:`, results)
        // All claims are now approved
        // You saw individual progress for each
        // You got a final summary message
      },
      error: (error) => {
        console.log("‚ùå Some approvals failed:", error)
        // You'll know which ones succeeded and which failed
      },
    })
  }

  // ‚úÖ MIXED OPERATIONS EXAMPLE
  mixedOperationsExample(): void {
    const operations: BatchOperation<any>[] = [
      {
        operation: this.claimsService.createClaimSrvc({
          claimNumber: "CLM-NEW-001",
          claimant: "New User",
          amount: 5000,
          status: "pending",
        }),
        loadingMessage: "Creating new claim...",
        successMessage: "New claim created!",
        errorMessage: "Failed to create claim",
      },
      {
        operation: this.claimsService.updateClaimSrvc("existing-1", { status: "approved" }),
        loadingMessage: "Approving existing claim...",
        successMessage: "Existing claim approved!",
        errorMessage: "Failed to approve claim",
      },
      {
        operation: this.claimsService.deleteClaimSrvc("old-claim"),
        loadingMessage: "Deleting old claim...",
        successMessage: "Old claim deleted!",
        errorMessage: "Failed to delete claim",
      },
      {
        operation: this.claimsService.exportClaimsSrvc("pdf"),
        loadingMessage: "Generating report...",
        successMessage: "Report generated!",
        errorMessage: "Failed to generate report",
      },
    ]

    // üöÄ This will show 4 different loading snackbars immediately
    this.advancedPatterns.runParallelOperations(operations).subscribe({
      next: (results) => {
        console.log("‚úÖ All mixed operations completed:", results)
        // results[0] = new claim data
        // results[1] = updated claim data
        // results[2] = delete confirmation
        // results[3] = report blob
      },
      error: (error) => {
        console.log("‚ùå Some operations failed:", error)
      },
    })
  }

  // ‚úÖ FILE PROCESSING EXAMPLE
  fileProcessingExample(): void {
    const files = ["document1.pdf", "document2.pdf", "spreadsheet1.xlsx", "image1.jpg"]

    const operations: BatchOperation<any>[] = files.map((filename) => ({
      operation: this.claimsService.exportClaimsSrvc("pdf"), // Simulating file processing
      loadingMessage: `Processing ${filename}...`,
      successMessage: `${filename} processed successfully!`,
      errorMessage: `Failed to process ${filename}`,
    }))

    // üöÄ This will show 4 file processing snackbars immediately
    this.advancedPatterns.runParallelOperations(operations).subscribe({
      next: (results) => {
        console.log(`‚úÖ All ${results.length} files processed:`, results)
        // All files are now processed
        // You can download them, show them, etc.
      },
      error: (error) => {
        console.log("‚ùå Some files failed to process:", error)
        // You'll know which files succeeded and which failed
      },
    })
  }
}
