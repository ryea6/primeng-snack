export type SnackbarType = 'success' | 'error' | 'warning' | 'info' | 'loading';
export type SnackbarPosition = 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'top-center' | 'bottom-center';

export interface SnackbarConfig {
  type: SnackbarType;
  title?: string;
  message: string;
  duration?: number; // milliseconds, 0 = persistent
  position?: SnackbarPosition;
  showCloseButton?: boolean;
  showIcon?: boolean;
  actionLabel?: string;
  actionCallback?: () => void;
  clickToClose?: boolean;
  pauseOnHover?: boolean;
  showProgress?: boolean;
  customClass?: string;
}

export interface SnackbarInstance {
  id: string;
  config: SnackbarConfig;
  createdAt: Date;
  isVisible: boolean;
  isPaused: boolean;
  progress: number;
}


import { Injectable, ComponentRef, ViewContainerRef, ApplicationRef, createComponent, EnvironmentInjector } from '@angular/core';
import { BehaviorSubject, Observable, timer, Subject, takeUntil } from 'rxjs';
import { ModernSnackbarComponent } from '../components/modern-snackbar.component';
import { SnackbarConfig, SnackbarInstance, SnackbarType, SnackbarPosition } from '../interfaces/snackbar.interface';

@Injectable({
  providedIn: 'root'
})
export class ModernSnackbarService {
  private snackbars$ = new BehaviorSubject<SnackbarInstance[]>([]);
  private containerRef?: ViewContainerRef;
  private componentRefs = new Map<string, ComponentRef<ModernSnackbarComponent>>();
  private defaultConfig: Partial<SnackbarConfig> = {
    duration: 5000,
    position: 'top-right',
    showCloseButton: true,
    showIcon: true,
    clickToClose: true,
    pauseOnHover: true,
    showProgress: true
  };

  constructor(
    private appRef: ApplicationRef,
    private injector: EnvironmentInjector
  ) {}

  /**
   * Set the container where snackbars will be rendered
   */
  setContainer(containerRef: ViewContainerRef): void {
    this.containerRef = containerRef;
  }

  /**
   * Get all active snackbars
   */
  getSnackbars(): Observable<SnackbarInstance[]> {
    return this.snackbars$.asObservable();
  }

  /**
   * Show a success snackbar
   */
  success(message: string, title?: string, config?: Partial<SnackbarConfig>): string {
    return this.show({
      type: 'success',
      title,
      message,
      ...config
    });
  }

  /**
   * Show an error snackbar
   */
  error(message: string, title?: string, config?: Partial<SnackbarConfig>): string {
    return this.show({
      type: 'error',
      title,
      message,
      duration: 0, // Errors are persistent by default
      ...config
    });
  }

  /**
   * Show a warning snackbar
   */
  warning(message: string, title?: string, config?: Partial<SnackbarConfig>): string {
    return this.show({
      type: 'warning',
      title,
      message,
      ...config
    });
  }

  /**
   * Show an info snackbar
   */
  info(message: string, title?: string, config?: Partial<SnackbarConfig>): string {
    return this.show({
      type: 'info',
      title,
      message,
      ...config
    });
  }

  /**
   * Show a loading snackbar
   */
  loading(message: string, title?: string): string {
    return this.show({
      type: 'loading',
      title,
      message,
      duration: 0, // Loading is persistent
      showCloseButton: false,
      clickToClose: false,
      showProgress: false
    });
  }

  /**
   * Show a custom snackbar
   */
  show(config: SnackbarConfig): string {
    const finalConfig = { ...this.defaultConfig, ...config };
    const id = this.generateId();
    
    const instance: SnackbarInstance = {
      id,
      config: finalConfig,
      createdAt: new Date(),
      isVisible: false,
      isPaused: false,
      progress: 100
    };

    // Add to active snackbars
    const current = this.snackbars$.value;
    this.snackbars$.next([...current, instance]);

    // Create and render component
    this.createSnackbarComponent(instance);

    // Auto-dismiss if duration is set
    if (finalConfig.duration && finalConfig.duration > 0) {
      this.startAutoDismiss(id, finalConfig.duration);
    }

    return id;
  }

  /**
   * Update an existing snackbar
   */
  update(id: string, updates: Partial<SnackbarConfig>): void {
    const current = this.snackbars$.value;
    const index = current.findIndex(s => s.id === id);
    
    if (index !== -1) {
      const updated = {
        ...current[index],
        config: { ...current[index].config, ...updates }
      };
      
      current[index] = updated;
      this.snackbars$.next([...current]);
      
      // Update component
      const componentRef = this.componentRefs.get(id);
      if (componentRef) {
        componentRef.instance.snackbar = updated;
      }
    }
  }

  /**
   * Dismiss a specific snackbar
   */
  dismiss(id: string): void {
    const componentRef = this.componentRefs.get(id);
    if (componentRef) {
      componentRef.instance.startDismissAnimation().then(() => {
        this.removeSnackbar(id);
      });
    }
  }

  /**
   * Dismiss all snackbars
   */
  dismissAll(): void {
    const current = this.snackbars$.value;
    current.forEach(snackbar => {
      this.dismiss(snackbar.id);
    });
  }

  /**
   * Clear all snackbars immediately
   */
  clear(): void {
    const current = this.snackbars$.value;
    current.forEach(snackbar => {
      this.removeSnackbar(snackbar.id);
    });
  }

  private createSnackbarComponent(instance: SnackbarInstance): void {
    const componentRef = createComponent(ModernSnackbarComponent, {
      environmentInjector: this.injector
    });

    componentRef.instance.snackbar = instance;
    componentRef.instance.onDismiss = () => this.dismiss(instance.id);
    componentRef.instance.onAction = () => {
      if (instance.config.actionCallback) {
        instance.config.actionCallback();
      }
      this.dismiss(instance.id);
    };

    // Attach to application
    this.appRef.attachView(componentRef.hostView);

    // Add to DOM
    const domElement = (componentRef.hostView as any).rootNodes[0] as HTMLElement;
    document.body.appendChild(domElement);

    // Store reference
    this.componentRefs.set(instance.id, componentRef);

    // Trigger entrance animation
    setTimeout(() => {
      componentRef.instance.show();
    }, 10);
  }

  private startAutoDismiss(id: string, duration: number): void {
    const destroy$ = new Subject<void>();
    let remainingTime = duration;
    const interval = 50; // Update every 50ms for smooth progress

    const updateProgress = () => {
      const instance = this.snackbars$.value.find(s => s.id === id);
      if (!instance) {
        destroy$.next();
        return;
      }

      if (!instance.isPaused) {
        remainingTime -= interval;
        instance.progress = Math.max(0, (remainingTime / duration) * 100);
        
        // Update component progress
        const componentRef = this.componentRefs.get(id);
        if (componentRef) {
          componentRef.instance.updateProgress(instance.progress);
        }
      }

      if (remainingTime <= 0) {
        this.dismiss(id);
        destroy$.next();
      }
    };

    timer(0, interval).pipe(
      takeUntil(destroy$)
    ).subscribe(() => updateProgress());
  }

  private removeSnackbar(id: string): void {
    // Remove from active snackbars
    const current = this.snackbars$.value;
    this.snackbars$.next(current.filter(s => s.id !== id));

    // Destroy component
    const componentRef = this.componentRefs.get(id);
    if (componentRef) {
      this.appRef.detachView(componentRef.hostView);
      componentRef.destroy();
      this.componentRefs.delete(id);
    }
  }

  /**
   * Pause auto-dismiss for a snackbar
   */
  pause(id: string): void {
    const current = this.snackbars$.value;
    const snackbar = current.find(s => s.id === id);
    if (snackbar) {
      snackbar.isPaused = true;
    }
  }

  /**
   * Resume auto-dismiss for a snackbar
   */
  resume(id: string): void {
    const current = this.snackbars$.value;
    const snackbar = current.find(s => s.id === id);
    if (snackbar) {
      snackbar.isPaused = false;
    }
  }

  private generateId(): string {
    return `snackbar_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import { Component, Input, OnInit, OnDestroy, HostBinding } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { SnackbarInstance } from '../interfaces/snackbar.interface';

@Component({
  selector: 'app-modern-snackbar',
  standalone: true,
  imports: [CommonModule, MatIconModule, MatButtonModule],
  template: `
    <div class="snackbar-container" 
         [ngClass]="getSnackbarClasses()"
         [@slideIn]="animationState"
         (mouseenter)="onMouseEnter()"
         (mouseleave)="onMouseLeave()"
         (click)="onClick()">
      
      <!-- Icon -->
      <div class="snackbar-icon" *ngIf="snackbar.config.showIcon">
        <mat-icon *ngIf="snackbar.config.type !== 'loading'">{{ getIcon() }}</mat-icon>
        <div class="loading-spinner" *ngIf="snackbar.config.type === 'loading'"></div>
      </div>

      <!-- Content -->
      <div class="snackbar-content">
        <div class="snackbar-title" *ngIf="snackbar.config.title">
          {{ snackbar.config.title }}
        </div>
        <div class="snackbar-message">
          {{ snackbar.config.message }}
        </div>
      </div>

      <!-- Action Button -->
      <button mat-button 
              *ngIf="snackbar.config.actionLabel"
              (click)="onActionClick($event)"
              class="snackbar-action">
        {{ snackbar.config.actionLabel }}
      </button>

      <!-- Close Button -->
      <button mat-icon-button 
              *ngIf="snackbar.config.showCloseButton"
              (click)="onCloseClick($event)"
              class="snackbar-close">
        <mat-icon>close</mat-icon>
      </button>

      <!-- Progress Bar -->
      <div class="snackbar-progress" 
           *ngIf="snackbar.config.showProgress && snackbar.config.duration && snackbar.config.duration > 0">
        <div class="progress-bar" [style.width.%]="progress"></div>
      </div>
    </div>
  `,
  styles: [`
    .snackbar-container {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      min-width: 300px;
      max-width: 500px;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .snackbar-container:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }

    .snackbar-container.clickable {
      cursor: pointer;
    }

    /* Type-specific styling */
    .snackbar-success {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
      color: white;
    }

    .snackbar-error {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.95), rgba(211, 47, 47, 0.95));
      color: white;
    }

    .snackbar-warning {
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.95), rgba(245, 124, 0, 0.95));
      color: white;
    }

    .snackbar-info {
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.95), rgba(25, 118, 210, 0.95));
      color: white;
    }

    .snackbar-loading {
      background: linear-gradient(135deg, rgba(96, 125, 139, 0.95), rgba(69, 90, 100, 0.95));
      color: white;
    }

    /* Icon */
    .snackbar-icon {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Content */
    .snackbar-content {
      flex: 1;
      min-width: 0;
    }

    .snackbar-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
      line-height: 1.2;
    }

    .snackbar-message {
      font-size: 13px;
      line-height: 1.4;
      opacity: 0.95;
    }

    /* Action Button */
    .snackbar-action {
      flex-shrink: 0;
      color: rgba(255, 255, 255, 0.9) !important;
      font-weight: 600 !important;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 12px !important;
    }

    .snackbar-action:hover {
      background: rgba(255, 255, 255, 0.1) !important;
    }

    /* Close Button */
    .snackbar-close {
      flex-shrink: 0;
      color: rgba(255, 255, 255, 0.8) !important;
      width: 32px !important;
      height: 32px !important;
      margin: -8px -4px -8px 0;
    }

    .snackbar-close:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      color: white !important;
    }

    /* Progress Bar */
    .snackbar-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255, 255, 255, 0.2);
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      transition: width 0.1s linear;
      border-radius: 0 3px 3px 0;
    }

    /* Animations */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Position classes */
    :host.position-top-right {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
    }

    :host.position-top-left {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 9999;
    }

    :host.position-bottom-right {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
    }

    :host.position-bottom-left {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
    }

    :host.position-top-center {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }

    :host.position-bottom-center {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .snackbar-container {
        min-width: 280px;
        max-width: calc(100vw - 40px);
        margin: 0 20px;
      }

      :host.position-top-center,
      :host.position-bottom-center {
        left: 20px;
        right: 20px;
        transform: none;
      }
    }
  `],
  animations: [
    trigger('slideIn', [
      state('hidden', style({
        opacity: 0,
        transform: 'translateX(100%) scale(0.8)'
      })),
      state('visible', style({
        opacity: 1,
        transform: 'translateX(0) scale(1)'
      })),
      state('dismissed', style({
        opacity: 0,
        transform: 'translateX(100%) scale(0.8)'
      })),
      transition('hidden => visible', animate('300ms cubic-bezier(0.4, 0, 0.2, 1)')),
      transition('visible => dismissed', animate('250ms cubic-bezier(0.4, 0, 0.2, 1)'))
    ])
  ]
})



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


export class ModernSnackbarComponent implements OnInit, OnDestroy {
  @Input() snackbar!: SnackbarInstance;
  
  animationState: 'hidden' | 'visible' | 'dismissed' = 'hidden';
  progress = 100;
  
  onDismiss?: () => void;
  onAction?: () => void;

  @HostBinding('class')
  get hostClasses(): string {
    return `position-${this.snackbar.config.position} ${this.snackbar.config.customClass || ''}`;
  }

  ngOnInit(): void {
    // Component starts hidden, show() will be called by service
  }

  ngOnDestroy(): void {
    // Cleanup if needed
  }

  show(): void {
    this.animationState = 'visible';
  }

  startDismissAnimation(): Promise<void> {
    return new Promise((resolve) => {
      this.animationState = 'dismissed';
      setTimeout(() => resolve(), 250);
    });
  }

  updateProgress(progress: number): void {
    this.progress = progress;
  }

  getSnackbarClasses(): string {
    const classes = [`snackbar-${this.snackbar.config.type}`];
    
    if (this.snackbar.config.clickToClose) {
      classes.push('clickable');
    }
    
    return classes.join(' ');
  }

  getIcon(): string {
    const iconMap = {
      success: 'check_circle',
      error: 'error',
      warning: 'warning',
      info: 'info',
      loading: 'hourglass_empty'
    };
    return iconMap[this.snackbar.config.type] || 'info';
  }

  onMouseEnter(): void {
    if (this.snackbar.config.pauseOnHover) {
      // Pause auto-dismiss (handled by service)
    }
  }

  onMouseLeave(): void {
    if (this.snackbar.config.pauseOnHover) {
      // Resume auto-dismiss (handled by service)
    }
  }

  onClick(): void {
    if (this.snackbar.config.clickToClose) {
      this.onDismiss?.();
    }
  }

  onActionClick(event: Event): void {
    event.stopPropagation();
    this.onAction?.();
  }

  onCloseClick(event: Event): void {
    event.stopPropagation();
    this.onDismiss?.();
  }
}

import { Component, Input, OnInit, OnDestroy, HostBinding } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { SnackbarInstance } from '../interfaces/snackbar.interface';

@Component({
  selector: 'app-modern-snackbar',
  standalone: true,
  imports: [CommonModule, MatIconModule, MatButtonModule],
  template: `
    <div class="snackbar-container" 
         [ngClass]="getSnackbarClasses()"
         [@slideIn]="animationState"
         (mouseenter)="onMouseEnter()"
         (mouseleave)="onMouseLeave()"
         (click)="onClick()">
      
      <!-- Icon -->
      <div class="snackbar-icon" *ngIf="snackbar.config.showIcon">
        <mat-icon *ngIf="snackbar.config.type !== 'loading'">{{ getIcon() }}</mat-icon>
        <div class="loading-spinner" *ngIf="snackbar.config.type === 'loading'"></div>
      </div>

      <!-- Content -->
      <div class="snackbar-content">
        <div class="snackbar-title" *ngIf="snackbar.config.title">
          {{ snackbar.config.title }}
        </div>
        <div class="snackbar-message">
          {{ snackbar.config.message }}
        </div>
      </div>

      <!-- Action Button -->
      <button mat-button 
              *ngIf="snackbar.config.actionLabel"
              (click)="onActionClick($event)"
              class="snackbar-action">
        {{ snackbar.config.actionLabel }}
      </button>

      <!-- Close Button -->
      <button mat-icon-button 
              *ngIf="snackbar.config.showCloseButton"
              (click)="onCloseClick($event)"
              class="snackbar-close">
        <mat-icon>close</mat-icon>
      </button>

      <!-- Progress Bar -->
      <div class="snackbar-progress" 
           *ngIf="snackbar.config.showProgress && snackbar.config.duration && snackbar.config.duration > 0">
        <div class="progress-bar" [style.width.%]="progress"></div>
      </div>
    </div>
  `,
  styles: [`
    .snackbar-container {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      min-width: 300px;
      max-width: 500px;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .snackbar-container:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }

    .snackbar-container.clickable {
      cursor: pointer;
    }

    /* Type-specific styling */
    .snackbar-success {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
      color: white;
    }

    .snackbar-error {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.95), rgba(211, 47, 47, 0.95));
      color: white;
    }

    .snackbar-warning {
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.95), rgba(245, 124, 0, 0.95));
      color: white;
    }

    .snackbar-info {
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.95), rgba(25, 118, 210, 0.95));
      color: white;
    }

    .snackbar-loading {
      background: linear-gradient(135deg, rgba(96, 125, 139, 0.95), rgba(69, 90, 100, 0.95));
      color: white;
    }

    /* Icon */
    .snackbar-icon {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Content */
    .snackbar-content {
      flex: 1;
      min-width: 0;
    }

    .snackbar-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
      line-height: 1.2;
    }

    .snackbar-message {
      font-size: 13px;
      line-height: 1.4;
      opacity: 0.95;
    }

    /* Action Button */
    .snackbar-action {
      flex-shrink: 0;
      color: rgba(255, 255, 255, 0.9) !important;
      font-weight: 600 !important;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 12px !important;
    }

    .snackbar-action:hover {
      background: rgba(255, 255, 255, 0.1) !important;
    }

    /* Close Button */
    .snackbar-close {
      flex-shrink: 0;
      color: rgba(255, 255, 255, 0.8) !important;
      width: 32px !important;
      height: 32px !important;
      margin: -8px -4px -8px 0;
    }

    .snackbar-close:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      color: white !important;
    }

    /* Progress Bar */
    .snackbar-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255, 255, 255, 0.2);
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      transition: width 0.1s linear;
      border-radius: 0 3px 3px 0;
    }

    /* Animations */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Position classes */
    :host.position-top-right {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
    }

    :host.position-top-left {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 9999;
    }

    :host.position-bottom-right {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
    }

    :host.position-bottom-left {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
    }

    :host.position-top-center {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }

    :host.position-bottom-center {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .snackbar-container {
        min-width: 280px;
        max-width: calc(100vw - 40px);
        margin: 0 20px;
      }

      :host.position-top-center,
      :host.position-bottom-center {
        left: 20px;
        right: 20px;
        transform: none;
      }
    }
  `],
  animations: [
    trigger('slideIn', [
      state('hidden', style({
        opacity: 0,
        transform: 'translateX(100%) scale(0.8)'
      })),
      state('visible', style({
        opacity: 1,
        transform: 'translateX(0) scale(1)'
      })),
      state('dismissed', style({
        opacity: 0,
        transform: 'translateX(100%) scale(0.8)'
      })),
      transition('hidden => visible', animate('300ms cubic-bezier(0.4, 0, 0.2, 1)')),
      transition('visible => dismissed', animate('250ms cubic-bezier(0.4, 0, 0.2, 1)'))
    ])
  ]
})
export class ModernSnackbarComponent implements OnInit, OnDestroy {
  @Input() snackbar!: SnackbarInstance;
  
  animationState: 'hidden' | 'visible' | 'dismissed' = 'hidden';
  progress = 100;
  
  onDismiss?: () => void;
  onAction?: () => void;

  @HostBinding('class')
  get hostClasses(): string {
    return `position-${this.snackbar.config.position} ${this.snackbar.config.customClass || ''}`;
  }

  ngOnInit(): void {
    // Component starts hidden, show() will be called by service
  }

  ngOnDestroy(): void {
    // Cleanup if needed
  }

  show(): void {
    this.animationState = 'visible';
  }

  startDismissAnimation(): Promise<void> {
    return new Promise((resolve) => {
      this.animationState = 'dismissed';
      setTimeout(() => resolve(), 250);
    });
  }

  updateProgress(progress: number): void {
    this.progress = progress;
  }

  getSnackbarClasses(): string {
    const classes = [`snackbar-${this.snackbar.config.type}`];
    
    if (this.snackbar.config.clickToClose) {
      classes.push('clickable');
    }
    
    return classes.join(' ');
  }

  getIcon(): string {
    const iconMap = {
      success: 'check_circle',
      error: 'error',
      warning: 'warning',
      info: 'info',
      loading: 'hourglass_empty'
    };
    return iconMap[this.snackbar.config.type] || 'info';
  }

  onMouseEnter(): void {
    if (this.snackbar.config.pauseOnHover) {
      // Pause auto-dismiss (handled by service)
    }
  }

  onMouseLeave(): void {
    if (this.snackbar.config.pauseOnHover) {
      // Resume auto-dismiss (handled by service)
    }
  }

  onClick(): void {
    if (this.snackbar.config.clickToClose) {
      this.onDismiss?.();
    }
  }

  onActionClick(event: Event): void {
    event.stopPropagation();
    this.onAction?.();
  }

  onCloseClick(event: Event): void {
    event.stopPropagation();
    this.onDismiss?.();
  }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { ModernSnackbarService } from '../services/modern-snackbar.service';

@Component({
  selector: 'app-snackbar-usage-example',
  standalone: true,
  imports: [CommonModule, MatButtonModule, MatCardModule],
  template: `
    <div class="example-container">
      <h1>🚀 Modern Snackbar Service</h1>
      <p>Beautiful, modern snackbars with glassmorphism design and smooth animations</p>
      
      <div class="examples-grid">
        <!-- Success Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>✅ Success</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show success messages with green gradient</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="primary" (click)="showSuccess()">
              Success Message
            </button>
            <button mat-button (click)="showSuccessWithAction()">
              With Action
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Error Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>❌ Error</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show error messages with red gradient (persistent)</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="warn" (click)="showError()">
              Error Message
            </button>
            <button mat-button (click)="showErrorWithRetry()">
              With Retry
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Warning Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>⚠️ Warning</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show warning messages with orange gradient</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button color="accent" (click)="showWarning()">
              Warning Message
            </button>
            <button mat-button (click)="showWarningPersistent()">
              Persistent
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Info Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>ℹ️ Info</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show info messages with blue gradient</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="showInfo()">
              Info Message
            </button>
            <button mat-button (click)="showInfoLong()">
              Long Message
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Loading Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>⏳ Loading</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show loading messages with spinner</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-raised-button (click)="showLoading()">
              Loading Message
            </button>
            <button mat-button (click)="showLoadingThenSuccess()">
              Loading → Success
            </button>
          </mat-card-actions>
        </mat-card>

        <!-- Position Examples -->
        <mat-card class="example-card">
          <mat-card-header>
            <mat-card-title>📍 Positions</mat-card-title>
          </mat-card-header>
          <mat-card-content>
            <p>Show snackbars in different positions</p>
          </mat-card-content>
          <mat-card-actions>
            <button mat-button (click)="showTopLeft()">Top Left</button>
            <button mat-button (click)="showBottomCenter()">Bottom Center</button>
          </mat-card-actions>
        </mat-card>
      </div>

      <!-- Control Buttons -->
      <div class="control-section">
        <h3>Controls</h3>
        <div class="control-buttons">
          <button mat-stroked-button (click)="dismissAll()">
            Dismiss All
          </button>
          <button mat-stroked-button (click)="clearAll()">
            Clear All
          </button>
        </div>
      </div>

      <!-- Code Examples -->
      <mat-card class="code-example">
        <mat-card-header>
          <mat-card-title>💻 Usage Examples</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <pre><code>// Simple usage
this.snackbar.success('Operation completed successfully!');
this.snackbar.error('Something went wrong', 'Error');
this.snackbar.warning('Please check your input');

// With custom config
this.snackbar.show({{
  type: 'info',
  title: 'New Feature',
  message: 'Check out our latest update!',
  actionLabel: 'Learn More',
  actionCallback: () => this.openFeatureGuide(),
  position: 'bottom-center',
  duration: 8000
}});

// Loading with update
const loadingId = this.snackbar.loading('Processing...');
// Later...
this.snackbar.update(loadingId, {{
  type: 'success',
  message: 'Processing complete!'
}});</code></pre>
        </mat-card-content>
      </mat-card>
    </div>
  `,
  styles: [`
    .example-container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 32px 0;
    }

    .example-card {
      height: 200px;
      display: flex;
      flex-direction: column;
    }

    .control-section {
      margin: 32px 0;
      text-align: center;
    }

    .control-buttons {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 16px;
    }

    .code-example {
      margin-top: 32px;
      background: #f8f9fa;
    }

    pre {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    mat-card-content {
      flex: 1;
    }

    mat-card-actions {
      padding: 16px;
    }

    h1 {
      color: #333;
      margin-bottom: 8px;
    }

    h3 {
      color: #555;
    }

    p {
      color: #666;
      line-height: 1.6;
    }
  `]
})
export class SnackbarUsageExampleComponent {
  constructor(private snackbar: ModernSnackbarService) {}

  showSuccess(): void {
    this.snackbar.success('Operation completed successfully!', 'Success');
  }

  showSuccessWithAction(): void {
    this.snackbar.success('File uploaded successfully!', 'Success', {
      actionLabel: 'View',
      actionCallback: () => console.log('View file clicked')
    });
  }

  showError(): void {
    this.snackbar.error('Something went wrong. Please try again.', 'Error');
  }

  showErrorWithRetry(): void {
    this.snackbar.error('Failed to save changes', 'Error', {
      actionLabel: 'Retry',
      actionCallback: () => console.log('Retry clicked')
    });
  }

  showWarning(): void {
    this.snackbar.warning('Please check your input before continuing', 'Warning');
  }

  showWarningPersistent(): void {
    this.snackbar.warning('Your session will expire soon', 'Session Warning', {
      duration: 0,
      actionLabel: 'Extend',
      actionCallback: () => console.log('Extend session')
    });
  }

  showInfo(): void {
    this.snackbar.info('New features are available in this update', 'Info');
  }

  showInfoLong(): void {
    this.snackbar.info('This is a longer message to demonstrate how the snackbar handles multiple lines of text gracefully', 'Long Message');
  }

  showLoading(): void {
    this.snackbar.loading('Processing your request...', 'Please Wait');
  }

  showLoadingThenSuccess(): void {
    const loadingId = this.snackbar.loading('Uploading file...', 'Please Wait');
    
    // Simulate async operation
    setTimeout(() => {
      this.snackbar.update(loadingId, {
        type: 'success',
        title: 'Complete',
        message: 'File uploaded successfully!',
        duration: 3000,
        showCloseButton: true
      });
    }, 3000);
  }

  showTopLeft(): void {
    this.snackbar.info('This appears in the top-left corner', 'Position Demo', {
      position: 'top-left'
    });
  }

  showBottomCenter(): void {
    this.snackbar.info('This appears at the bottom center', 'Position Demo', {
      position: 'bottom-center'
    });
  }

  dismissAll(): void {
    this.snackbar.dismissAll();
  }

  clearAll(): void {
    this.snackbar.clear();
  }
}










// Simple usage
this.snackbar.success('Saved successfully!');
this.snackbar.error('Something went wrong');

// Advanced usage
this.snackbar.show({
  type: 'info',
  title: 'New Feature',
  message: 'Check out our latest update!',
  actionLabel: 'Learn More',
  actionCallback: () => this.openGuide(),
  position: 'bottom-center',
  duration: 8000
});

// Loading states
const id = this.snackbar.loading('Processing...');
// Later update to success
this.snackbar.update(id, {
  type: 'success',
  message: 'Complete!'
});
